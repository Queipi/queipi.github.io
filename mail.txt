Dear Dr Zdun

For the last two months, I have been reading some publications of the Architecture group, as well as reflecting on how my own interests could best fit in it.
I wish to expand a bit upon this, in order to give you a better idea of what I'm aiming at and why I approached you.
I will also review some areas the group is currently working on and detail how they relate.

During our conversation, you said I had interest in variety of subjects across the field of Computer Science, but I believe I'm actually focusing on a very precise one: the fundamentals of software design.
As a professional software developer, I consistently find myself relying on my intuition to take design decisions which will impact the quality of the product (reliability, performance, evolvability, etc.)
In these cases, I often wished to have a guidance: ideally a formal framework in which the problem could be expressed.
Lacking such a tool, I did my best to clarify and formalize my decisions into a system of a sort, and it appeared to me that the same principles were underlying my decisions in very different areas, such as software architecture, module design, data models, file formats, version-control and many more.

In short, these principles boil down to the concept of "Separation of Concerns":
1. The "physical" structure of a software system should match its logical structure. (However, this doesn't mean that the logical structure entirely determines the physical one, as an aspect of the physical structure is related to the supporting infrastructure, which is independent of the logical structure.)
2. There is a distinction between the "vertical separation" (between different layers of abstraction) and the "horizontal separation" (between different concerns belonging to the same layer of abstraction.) A lot of software are build like stacks, dependencies upon dependencies, and would benefit from a more horizontal architecture.
3. A complete separation between two concerns is always a trichotomy, because the coupling of these two concerns is a logical entity by itself and should be treated as such in the physical structure. (This applies to the vertical AND to the horizontal separation.)
I understand that I may not express myself clearly there, since these are abstract ideas described with my own terminology, so I'll give more concrete examples in the rest of the mail.

So here is my motivation: I want to participate in providing guidance to architects and developers alike (from my experience, many architectural decisions are actually left to the developers) and this either for big enterprise solutions or for small scale programs.
While I do believe that these problems should be addressed within a common framework, I wish to study each individual use case independently and critically.

My "principles" may turn out to be entirely wrong.
In professional capacity, I cannot confront them as much as I would like to different situations, or have them challenged by people of a different mind and wider knowledge.
This is what brought me to have this conversation with you and discuss how I may integrate the Software Architecture Group, I hope this give you a better insight of my motivations and whether I would be an interesting candidate.

Best regards

Pierre-Jean Qu√©val

# Examples of the principles applied to different areas:

1. Layers of abstraction in a software:
the best defined separation is between the CPU's instruction set and the structured programming layer.
They have been well uncoupled in that way that each can be defined without referring to the other ; the compiler is the third part of the trichotomy, which make the link between the two Independent parts.
Structured programming mostly abstracts everything related to the physical details of the CPU's operations.
Other levels of abstraction are emerging but haven't been really formally defined yet, for example a module level (which would abstract the flow of execution, cf. the POO or the functional paradigm) or a semantic level (which would be expressed only in terms of business needs and concepts.)

2. Function's arguments, dependency injection, Bridge pattern :
these three concepts apply the same principle on different layers of abstraction: turning a vertical coupling into a horizontal one, in which neither part is dependent upon the other.
Function's arguments allow separating retrieving a value and using it.
Dependency injection separate a parent object and its dependencies.
The bridge pattern separate a contract and its implementation.
In the latter, for example, a contract and a module are written independently, none being dependent upon the other, and the bridge makes the module an implementation of the contract, again the third part of the trichotomy.

3. Data models:
the best data models for data manipulation (i.e. not data storage or transmission) tend to be isomorphic with their domain : every element of the domain has a model and every model corresponds to an element of the domain.
This makes designing data models very similar to designing software.

4. File formats:
a file is an unbreakable and self-sufficient bloc of information, or at least it should be.
A file too big or too small is not flexible, as the big one will contain to much unrelated information, and the small one will be too dependent upon its neighbors.
A good file can be moved, renamed and transferred, and stay meaningful.
In this sense, the file is a "concern" whose horizontal and vertical coupling should be kept minimal.
The horizontal coupling is simply how reliant on other files it is to be meaningful.
The vertical coupling is how specific the format/encoding is ; a needlessly complex format will make the information harder to maintain, manipulate and communicate.

5. Version control :
a tool like Git defines a hierarchy of incremental changes: commit, push, pull, merge.
There is obviously a separation of concerns at play there : a commit should be an atomic increment, the smallest technically meaningful change.
Conversely, the pull should also be atomic in its own way, the smallest functionally meaningful change.
I did not investigate this very far but there seems to be a relationship with the different layers of abstraction.

6. Errors:
errors can be classified in different categories ; I usually distinguish between consistency, complexity, correctness and exceptions.
Some of them are horizontal, e.g. breaking a precondition in the flow of execution and some are vertical, e.g. breaking an assumption on which the higher level relies.
This means that handling errors is very much a design and architectural problem, especially in the case of correctness or breaking an assumption (consistency and complexity errors are more the field of formal verification and such.)

7. Unit Tests:
similarly to the errors, some unit tests are horizontal, when they check the syntactic compatibility of different elements on the same layer, and others are vertical, when they check the semantic conformity of an element to the requirements of the upper layer.

8. Cross-cutting concerns:
trichotomy offers an obvious and powerful way to handle cross-cutting concerns. 
Logging for example can be integrated in the connecting structure between two concerns and not within the concern itself.

# Subjects in the Software Architecture Group

I reviewed the keywords on the website of your group :

1. Software patterns: 
they constitute the outline of an Independent layer of abstraction over the layer of structured programming.
In this, the popular notion that they are "missing features" is somehow right but maybe short-sighted, as I don't think there would be a benefit in integrating them in the currently existing programming languages.
However, they could be the building bloc of an Independent and higher-level formalism.

2. Design decisions: 
it should go without saying ; design decisions are the core of my endeavor.
I believe strongly that the lack of a "framework of development design" is the biggest problem that the CS-related fields face.
It strongly hinders the efforts of everyone in the industry, the academic field and the open-source communities alike.

3. SOA, EDA and MDD: 
I'm not very well acquainted with them yet, although I read about them a bit these last two months.
I find them interesting because they offer a basis for a topmost layer of abstraction, namely the semantic layer.
While a lower layer would separate the application into components, then into modules, then into functions, and so on... , a service would define a single business functionality which effects transversely every the parts of the application.
The topmost layer of abstraction should basically be a formal expression of the specifications with no dependency on the implementation, and (micro-)services, domain model and events could be a good approach to this.

4. DSL: 
they are a powerful and, in my opinion, under-employed tool.
In a sense, every layer of abstraction defines a "language" in which the upper-level can express a need.
A domain specific language allows an unprecedented level of abstraction between layers, allowing a need to be expressed with no dependency on the lower-level implementation.